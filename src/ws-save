#! /usr/bin/env bash
# Save first level CVS in the folder to specified file as in rosinstall format.
# Uses git's origin as url

set -e
set -u

POSTFIX=-workspace

usage(){
  __short_description="Save a workspace as a .rosinstall file"
  cat 1>&2 << EOF
$__short_description

Usage:
  $(basename $0) [-o <OUTPUT_FILENAME>] [-C] [<WORKSPACE_PATH>] 

  <WORKSPACE_PATH>: Path to the workspace that you want to save.
    If omitted, use ROS_WORKSPACE.
  Packages for which no remote is specified or which are not under source control are
    highlighted in red and marked with !. These can not be managed properly.

  -o  Ouput file. Default <WORKSPACE_PATH>/*$POSTFIX/workspace.rosinstall

  -C  No color ouput 

  -h  Print this help message.
EOF
}

OUTPUT_FILENAME=
COLOR=yes
while getopts "ho:C" OPTION
do
  case $OPTION in
    o)
      OUTPUT_FILENAME=$OPTARG
      ;;
    C)
      COLOR=
      ;;
    h|?)
      usage
      exit 1
      ;;
  esac
done
shift $((OPTIND-1))

if [ -z "$*" ]; then
  # Case for no arguments
  set +u
  if [ -n "$ROS_WORKSPACE" ]; then
    WORKSPACE_PATH=$ROS_WORKSPACE
  else
    echo "ROS_WORKSPACE is not set. Please manually specify the path." 1>&1
    exit 1
  fi
  set -u
else
  if [ -d "$1" ]; then
    WORKSPACE_PATH=$1
  else
    echo "$1 is not a directory" 1>&2
    exit 1
  fi
fi
# Expand relative paths
WORKSPACE_PATH=$(cd $WORKSPACE_PATH && pwd)

if [ -z "$OUTPUT_FILENAME" ]; then
  # Save location is not specified, use default
  OUTPUT_FILENAME=$WORKSPACE_PATH/$(basename $WORKSPACE_PATH)$POSTFIX/workspace.rosinstall
fi

if [ ! -e "$(dirname $OUTPUT_FILENAME)" ]; then
  # Create directory if does not exists
  mkdir "$(dirname $OUTPUT_FILENAME)"
fi
echo "Saving ${WORKSPACE_PATH#$(pwd)}. workspace into .${OUTPUT_FILENAME#$(pwd)}"


pushd $WORKSPACE_PATH > /dev/null

# We are now at the location, crawl first-level CVS and get info
rosinstall_text=""
for dir in `ls -d -- */`; do
  dir_name=`echo $dir| sed "s/\///"`
  pushd $dir_name > /dev/null

  pack_type=""
  uri=""
  version=""
  # Not supporting more than one VCS for a single directory

  #############################
  # GIT
  #############################
  if [ -d ".git" ];then
    pack_type=git
    # Prefer origin
    uri=$( git remote -v | grep origin | head -n1 | cut -d' ' -f1 | sed s/origin//| tr -d '\011')
    version=$(git status | grep "On branch" | rev |cut -d' ' -f1 | rev)
    if [ -z "$version" ]; then
      version=$(git describe --always --tags --long)
    fi
  #############################
  # MERCURIAL
  #############################
  elif [ -d ".hg" ];then
    pack_type=hg
    # Prefer default
    uri=$( hg paths |grep default | head -n1 | cut -d' ' -f3)
    version=$(hg branch)
    if [ -z "$version" ]; then
      version=$(hg log -r . --template '{latesttag}-{latesttagdistance}-{node|short}\n')
    fi
  #############################
  # SVN
  #############################
  elif [ -d ".svn" ];then
    pack_type=svn
    uri=$(svn info | grep URL |cut -d' ' -f2)
    version=r$(svn info |grep Revision | cut -d' ' -f2)
  else
    pack_type=other
  fi

  if [ -z "$uri" ]; then
    # If no uri, would not be able to update
    pack_type=other
  fi

  # Print status line
  color=
  coloroff=
  marker=" "
  if [ -z "$uri" ]; then
    marker="!"
    if [ -n "$COLOR" ]; then
      color="\033[0;31m"
      coloroff="\033[0;m"
    fi
  fi
  echo -e "$color $marker$pack_type ($version): $dir$coloroff"

  if [ -n "$uri" ]; then uri=", uri: ""'""$uri""'"""; fi
  if [ -n "$version" ]; then version=", version: $version"; fi
  local_name="local-name: ""'""$dir_name""'""" # need quotations, rosws goes belly-up

  rosinstall_text=$rosinstall_text"- $pack_type: {$local_name$uri$version}\n"
  popd > /dev/null
done

popd > /dev/null

# Save the generated rosinstall
echo "# Generated by $(basename $0)" > $OUTPUT_FILENAME
echo -e $rosinstall_text >> $OUTPUT_FILENAME
