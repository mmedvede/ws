#! /usr/bin/env bash
# Save first level CVS in the folder to specified file as in rosinstall format.
# Uses git's origin as url

set -e
set -u

POSTFIX=-workspace

usage(){
  __short_description="Save a workspace as a .rosinstall file"
  cat 1>&2 << EOF
$__short_description

Usage:
  $(basename $0) [-o <OUTPUT_FILENAME>] [-C] [<WORKSPACE_PATH>] 

  <WORKSPACE_PATH>: Path to the workspace that you want to save.
    If omitted, use ROS_WORKSPACE.
  Packages for which no remote is specified or which are not under source control are
    highlighted in red and marked with !. These can not be managed properly.

  -o  Ouput file. Default <WORKSPACE_PATH>/*$POSTFIX/workspace.rosinstall

  -C  No color ouput 

  -h  Print this help message.
EOF
}

OUTPUT_FILENAME=
COLOR=yes
while getopts "ho:C" OPTION
do
  case $OPTION in
    o)
      OUTPUT_FILENAME=$OPTARG
      ;;
    C)
      COLOR=
      ;;
    h|?)
      usage
      exit 1
      ;;
  esac
done
shift $((OPTIND-1))

if [ -z "$*" ]; then
  # Case for no arguments
  set +u
  if [ -n "$ROS_WORKSPACE" ]; then
    WORKSPACE_PATH=$ROS_WORKSPACE
  else
    echo "ROS_WORKSPACE is not set. Please manually specify the path." 1>&2
    exit 1
  fi
  set -u
else
  if [ -d "$1" ]; then
    WORKSPACE_PATH=$1
  else
    echo "$1 is not a directory" 1>&2
    exit 1
  fi
fi
# Expand relative paths
WORKSPACE_PATH=$(cd $WORKSPACE_PATH && pwd)

if [ -z "$OUTPUT_FILENAME" ]; then
  # Save location is not specified, use default
  OUTPUT_FILENAME=$WORKSPACE_PATH/$(basename $WORKSPACE_PATH)$POSTFIX/workspace.rosinstall
fi

if [ ! -e "$(dirname $OUTPUT_FILENAME)" ]; then
  # Create directory if does not exists
  mkdir "$(dirname $OUTPUT_FILENAME)"
fi
echo "Saving ${WORKSPACE_PATH#$(pwd)}. workspace into .${OUTPUT_FILENAME#$(pwd)}"


pushd $WORKSPACE_PATH > /dev/null

# We are now at the location, crawl first-level CVS and get info
rosinstall_text=""
gen_rosinstall_entry(){
  pack_type=""
  uri=""
  version=""
  unknown_cvs=""
  # Not supporting more than one VCS for a single directory

  #############################
  # GIT
  #############################
  if [ -d ".git" ];then
    pack_type=git
    # Prefer origin
    uri=$( git remote -v | grep origin | head -n1 | cut -d' ' -f1 | sed s/origin//| tr -d '\011')
    version=$(git status | grep "On branch" | rev |cut -d' ' -f1 | rev)
    if [ -z "$version" ]; then
      version=$(git describe --always --tags --long)
    fi
  #############################
  # MERCURIAL
  #############################
  elif [ -d ".hg" ];then
    pack_type=hg
    # Prefer default
    uri=$( hg paths |grep default | head -n1 | cut -d' ' -f3)
    version=$(hg branch)
    if [ -z "$version" ]; then
      version=$(hg log -r . --template '{latesttag}-{latesttagdistance}-{node|short}\n')
    fi
  #############################
  # SVN
  #############################
  elif [ -d ".svn" ];then
    pack_type=svn
    uri=$(svn info | grep URL |cut -d' ' -f2)
    version=r$(svn info |grep Revision | cut -d' ' -f2)
  else
    pack_type=other
    unknown_cvs=yes
  fi

  if [ -z "$uri" ]; then
    # If no uri, would not be able to update
    pack_type=other
  fi

  current_dir="$(pwd)"
  rel_name=${current_dir##$WORKSPACE_PATH/}

  # Print status line - disabled, as we do not have full info about recursion
  #color=
  #coloroff=
  #marker=" "
  #if [ -z "$uri" ]; then
    #marker="!"
    #if [ -n "$COLOR" ]; then
      #color="\033[0;31m"
      #coloroff="\033[0;m"
    #fi
  #fi
  #if [ -z "$unknown_cvs" ]; then
    #echo -e "$color $marker$pack_type ($version): $rel_name$coloroff" 1>&2
  #fi

  if [ -n "$uri" ]; then uri=", uri: ""'""$uri""'"""; fi
  if [ -n "$version" ]; then version=", version: $version"; fi
  local_name="local-name: ""'""$rel_name""'""" # need quotations, rosws goes belly-up

  echo "- $pack_type: {$local_name$uri$version}\n"
  if [ -z "$unknown_cvs" ]; then
    return 0
  else
    return 1
  fi
}

yellow="\033[0;33m"
coloroff="\033[0;m"

recurse(){
  local count=$1
  count=$((count-1))
  if [ "$count" -le 0 ]; then
    # Uncmment to save deepest folders as other
    #rosinstall_text=$rosinstall_text"$(gen_rosinstall_entry || true)"
    echo -en "$yellow Skipped:$coloroff $(gen_rosinstall_entry || true)"
    return
  else

    repo=$(gen_rosinstall_entry) && rosinstall_text=$rosinstall_text"$repo" && return
    
    dir_list=$(ls -d -- */ 2> /dev/null || true)
    if [ -z "$dir_list" ]; then
      # Uncomment to save folders with no subfolders as other
      #rosinstall_text=$rosinstall_text"$repo"
      echo -en "$yellow Skipped:$coloroff $repo"
      return 
    fi
    for dir in $dir_list; do
      dir_name=`echo $dir| sed "s/\///"`
      pushd $dir_name > /dev/null
      recurse $count
      popd > /dev/null
    done

  fi
}

recurse 4

echo -e $rosinstall_text

popd > /dev/null

# Save the generated rosinstall
echo "# Generated by $(basename $0)" > $OUTPUT_FILENAME
echo -e $rosinstall_text >> $OUTPUT_FILENAME
