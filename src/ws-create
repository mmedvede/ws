#! /usr/bin/env bash
# Create workspace meta package that contains .rosinstall file (generated using ws-save)
# and minimal initialization script

set -e
set -u

# This has to be in sync with the one ws-save uses
POSTFIX="-workspace"

usage(){
  __short_description="Create a new workspace from current directory"
  cat 1>&2 << EOF
$__short_description

Usage: $(basename $0) [-fhr]

  -f  Force workspace creatiion even if the $POSTFIX exists. 
      Deletes the existing metapackage.

  -r <REMOTE> Specify remote uri for the metapackage.

  -h  Print this help message.

Saves the versions of all projects under
source control (not recursive) into *$POSTFIX. 
It also saves regular folders, but there is not way
to maintain those unless they are under source control.
The initialize helper script also placed in the metapackage.
After the *$POSTFIX metapackage is created, it is 
put under vcs (git). Finally the workspace initialized using
the script.
EOF
}

FORCE=
REMOTE=
while getopts "hfr:" OPTION
do
  case $OPTION in
    f)
      FORCE=1
      ;;
    r)
      REMOTE=$OPTARG
      ;;
    h|?)
      usage
      exit 1
      ;;
  esac
done

# Do not do anything if no ROS.
# We still depend on ROS.
# The behavior is to use current ROS according to "rosversion", fallback on the
# latest ROS in /opt/ros, and if no ROS there, fail.
if [ -z "$(which rosversion)" ]; then
  echo "ROS not found. See http://www.ros.org/wiki/ROS/Installation" 1>&2
  exit 2
fi

if [ -z "$(rosversion -d)" -o "$(rosversion -d)" = "<unknown>" ]; then
  if [ -d /opt/ros  ]; then
    __ros_version=$(find /opt/ros -maxdepth 1 -type d -printf '%P\n' | sort | tail -1)
    if [ -z "$__ros_version" ]; then
      echo "No ROS installation found." 1>&2
      exit 1
    fi
    ros_path=/opt/ros/$__ros_version
  fi
else
  __ros_version=$(rosversion -d)
  ros_path=$(dirname $(dirname $ROS_ROOT))
fi
echo "Using ROS $__ros_version"

# Do not do anything if the metapackage already exists
metapack_dir=$(basename $(pwd))$POSTFIX
if [ -e "$metapack_dir" ]; then
  echo "$metapack_dir already exists in working directory" 1>&2
  [[ -z "$FORCE" ]] && exit 1
  echo -e "\nRemoving $metapack_dir" 1>&2
  rm -Ivr $metapack_dir
fi

if [ -e .rosinstall ]; then
  echo -e "\nRemoving .rosinstall" 1>&2
  rm -Ivr .rosinstall
fi
# Expand path
mkdir $metapack_dir
metapack_dir=$(cd $metapack_dir && pwd)


# Generate .rosinstall
echo "Saving current directory as a workspace.rosinstall"
ws-save .



# Would you like some bash generated by bash that has been generated by this?
# Sure there is a clearer way to do it. But this way this initialization script
# is self-contained. 
SCRIPT_PATH=$metapack_dir/initialize
echo "Creating $SCRIPT_PATH"
echo \
  '#! /usr/bin/env bash
# Workspace initialization script.

WSRC=.roswsrc
WSRC_PATH=''~/''$WSRC
ENV_FILE=''~/ros_env.sh''

set -e

# Check for correct ROS version and source corresponding setup.bash
ROS_VERSION='$__ros_version'

if [ -z "$(rosversion -d)" -o "$(rosversion -d)" = "<unknown>" ]; then
  __default_ros=/opt/ros/$ROS_VERSION
  echo "No ROS on path, trying default at $__default_ros" 1>&2
  if [ -e "$__default_ros/setup.bash" ]; then
    echo "Found ROS at $__default_ros" 1>&2
    source $__default_ros/setup.bash
  else
    echo "Make sure the ROS is properly configured / on the path" 1>&2
    exit 1
  fi
elif [ "$(echo $ROS_VERSION | head -c1)" != "$(rosversion -d | head -c1)" ]; then
  echo "This workspace is expecting ROS $ROS_VERSION, detected $(rosversion -d)" 1>&2
  exit 1
fi
# At this point we should have ROS setup.bash sourced.

thisdir=$(cd $(dirname $0); pwd)
thisdirname=$(basename $thisdir)
name=$(echo $thisdirname | rev | cut -d"-" -f2- | rev) # Use "-" as separator, gitorious can not handle dots
updir=$(dirname $thisdir)
updirname=$(basename $updir)

if [ "$updirname" != "$name" ];then
  echo "Make sure $thisdirname is located inside $name as follows: $name/$thisdirname (the names should match).
  The workspace would be initialized in the parent directory." 1>&2
  exit 1
fi

#################################################
# Helper functions
green=$(echo -e "\033[0;32m")
red=$(echo -e "\033[0;31m")
grey=$(echo -e "\033[0;90m")
bwhite=$(echo -e "\033[1;37m")
no_color=$(echo -e "\033[0;m")

__draw_line(){
  char=$1
  text=" $2 "
  text_color=$3
  if [ -z "$text_color" ]; then text_color=$no_color; fi
  terminal_width=$(tput cols) 
  let w2=$((($terminal_width-${#text})/2))
  line=$(for (( c=0; c<$w2; c++)); do echo -n $char; done)
  echo -e "\n$grey$line$text_color$text$grey$line$no_color"
}

__exec_longrunning(){
  echo "$*$grey "
  $* 2>&1 | cut -b1-$(tput cols) | sed -u "i\\o033[2K" | stdbuf -o0 tr "\n" "\r"
  echo $no_color
}

__exec(){
  echo "$*$grey "
  $*
  echo $no_color
}

__source_hooks(){
  # would source files in alphabetical order in the folder $1
  # Not sure what variables should be available to sourced files.
  if [ ! -e $1 ]; then
    return
  fi
  __draw_line + "sourcing files in $1" $bwite
  files=$(find $1 -maxdepth 1 -type f | sort)
  for file in $files; do
    echo "$bwite$(basename $file)"
    source $file
  done
}

# Some error handling
success=""
__unsuccessfull_exit(){
  if [ -z "$success" ]; then
    __draw_line ^ "Did not finish, check any errors" $red
  fi
} &&
  trap __unsuccessfull_exit EXIT


ROSWS_INSTALL_DIR=$updir
ROSINSTALL_FILE=$thisdir/workspace.rosinstall

initialize-prerequisites(){
  __draw_line + "Setting up tools required to initialize the workspace"
  __exec_longrunning sudo apt-get install -y --force-yes python-rosinstall 
}

initialize-workspace()
{
  __draw_line + "Initializing workspace: $ROSINSTALL_FILE"
  # Overlay over current ROS environment
  __exec rosinstall $ROSWS_INSTALL_DIR $(dirname $(dirname $ROS_ROOT)) $ROSINSTALL_FILE

  source $ROSWS_INSTALL_DIR/setup.bash
}

initialize-build-workspace(){
  __draw_line + "Building the workspace"
  __exec_longrunning rosmake -a 
}

initialize-eclipse-projects(){
  __draw_line + "Building workspace eclipse projects"
  __exec_longrunning rosmake -a --target=eclipse-project 
}

initialize-generate-env-loader(){
echo '"'$(ws_generate_env_loader)'"'
}

initialize-write-env-loader(){
__draw_line + "(Over)writing $ENV_FILE"
initialize-generate-env-loader  > $ENV_FILE &&
  chmod +x $ENV_FILE
}


initialize-generate-workspace-rc(){
echo '"'$(ws_generate_workspace_rc '"$ROSWS_INSTALL_DIR"')'"'

# Below is the place to put non-essential commands that 
# would be run each time the workspace rc is sourced from interactive shell.
# There are no guarantees that it would be sourced, so 
# your system should not depend on these to work properly.
# An example is to print out the workspace state, help messages, etc."

# echo "# Status hooks"
}

initialize-write-workspace-rc(){
  __draw_line + "(Over)writing $WSRC_PATH"
  initialize-generate-workspace-rc > $WSRC_PATH
}

success-message(){
  __draw_line = Done $green
  echo "
  ## To start using the workspace: 
  source $ROSWS_INSTALL_DIR/setup.bash
  ## or
  source $WSRC_PATH 
  ## Alternatively, add either to your ~/.bashrc
  "
}


if [ -z "$*" ]; then
  __draw_line = "Workspace initialization script for $name"

  initialize-prerequisites
  initialize-workspace
  __source_hooks $thisdir/hooks/prebuild
  initialize-build-workspace
  initialize-eclipse-projects
  __source_hooks $thisdir/hooks/postbuild
  initialize-write-env-loader
  initialize-write-workspace-rc
  success-message
else
  initialize-$*
fi

success="yes"
' \
  > $SCRIPT_PATH && chmod +x $SCRIPT_PATH


echo "Putting it under git vcs"
pushd $metapack_dir > /dev/null
git init && git add . && git commit -am"[$(basename $0)] initial: saves $(basename $(dirname $metapack_dir)) workspace"
[[ -n $REMOTE ]] && git remote add --tags -t master -m master origin $REMOTE
echo "Let metapackage track itself, adding it to the workspace"
ws-save ..
git commit -am"[$(basename $0)] initial: adds $(basename $metapack_dir) to the workspace"
popd >/dev/null

# Use generated workspace.rosinstall and initialize overlayed workspace
rosws init . $ros_path 
rosws merge $metapack_dir/workspace.rosinstall -t .

echo "Done"
